*模板元编程是门很复杂的黑魔法，近期踩坑，特地整理了下自己对这方面的理解*

模板元编程（template metaprogram），按照翻译过来的意思是，编写可以编程序的程序，而模板元程序（Template Metaprogram），是可以编程序的程序。换而言之，根据corder给出的代码产生规则，编译器在编译期解释这些规则，并生成新代码来实现预期的功能，为自动代码的生成提供方便。

就当前个人的经验来看，在使用C++的模板元编程的时候，主要是用于将负载由运行期转移到编译期。负载可以理解是程序运行本身的开销，将运行时的计算转移到编译时完成，计算分为两种，**数值计算和类型计算。**

数值计算举个斐波那契数列的例子：

```
template<int N>
struct Fib
{
    enum { Result = Fib<N-1>::Result + Fib<N-2>::Result };
};

//特化值为 1 的版本
template <>
struct Fib<1>
{
    enum { Result = 1 };
};

//特化值为 0 的版本
template <>
struct Fib<0>
{
    enum { Result = 0 };
};

int main()
{
    int f = Fib<6>::Result;
} 
```

通过模板特化的机制，实现编译器条件选择结构，利用递归模板实现编译期循环结构。这里，会发现，在所要求的值在编译时已经确定，相当于变相的将运行时的计算提前完成。除非是追求极致性能，一般不推荐用数值计算，毕竟代码变得更加复杂了，也更难以debug。

再举一个类型计算的例子：

```
template <bool flag, typename T1, typename T2>
struct contain {
    typedef T1 value;
}

template <false, typename T1, typename T2>
struct contain {
    typedef T2 value;
}
```

类型计算主要提供在编译期通过传入的变量类型计算模板中对应的类型。上述例子比较简单，但类型计算是一个非常有用的功能，比如STL的迭代器，就是基于类型计算来实现的类型萃取。

当然，C++的模板元编程远不止这些用途，比如其一个重要的用途是补充类型系统，该功能很好的解决了物理上的量纲分析问题，是一个非常有意义的功能，这些后续自己去慢慢学习吧。